CodeFlow: The Debugging Odyssey - Detailed Screen-by-Screen Prompt
Game Title: CodeFlow: The Debugging Odyssey
Genre: 2D Puzzle-Platformer
Platform: PyGame
Core Theme: Gamified programming logic, problem-solving, AI-assisted debugging.

Screen 1: Splash & Welcome Screen
Visuals:
Background: A deep, pulsating blue/purple gradient, hinting at digital energy. Subtle, slow-moving particle effects (like tiny bits of data flowing).
Main Title: "CodeFlow" in a sleek, slightly glowing, futuristic font, perhaps with a subtle glitch effect that resolves. "The Debugging Odyssey" in a smaller, equally modern font below.
Central Element: A stylized, glowing circuit board or abstract network pattern.
Micro-Animation:
Particle Flow: Continuously flowing, almost like data streams, in the background.
Title Glitch: The "CodeFlow" title momentarily glitches and corrects itself every few seconds.
Circuit Glow: The central circuit pattern subtly brightens and dims in rhythm with the background pulse.
Sound: A soft, ambient electronic hum. Subtle, rhythmic beeps.
User Interaction:
"CLICK TO BEGIN" / "PRESS ANY KEY" Prompt: A flashing, easy-to-read prompt at the bottom center.
Micro-Animation: The prompt subtly pulses or changes color slightly to draw attention.
Purpose: Introduce the game's aesthetic and prepare the player for the experience.
Screen 2: Authentication Screen
Visuals:
Background: Similar to the splash screen, but slightly darker, less distracting. Perhaps a subtle grid overlay.
Central Panel: A clean, translucent login form resembling a digital terminal window, with rounded corners and a soft inner glow.
Elements:
"Login to your CodeFlow Account" heading.
"Username:" input field (text cursor blinking).
"Password:" input field (text cursor blinking).
"Remember Me" checkbox (stylized, glowing checkmark when active).
"Login" button.
"Create Account" button.
"Guest Play" button (for immediate play without account).
Micro-Animation:
Input Field Glow: When an input field is active, it has a subtle blue glow around its border.
Button Hover: Buttons slightly brighten or scale up/down when hovered over.
Text Cursor: Standard blinking cursor.
Checkbox Toggle: Smooth transition from empty to checked state.
Sound: Soft electronic clicks on button presses/field selection. A subtle "ding" on successful login.
User Interaction:
Keyboard input for username/password.
Mouse click for buttons and checkbox.
Error Handling: If login fails, a small, red, slightly transparent error message pops up momentarily (e.g., "Invalid credentials").
Purpose: Allow players to save their progress and access leaderboards (future feature implied by "game score"). Acknowledge that the challenge is focused on the game itself, so the authentication can be simplified for this specific context.
Screen 3: Main Menu / Level Select Screen
Visuals:
Background: A dynamic, abstract representation of interconnected code modules or network nodes. Lines subtly flow between them, indicating connections.
Central Character (Player Avatar): The "Code Cleaner" character (a small, agile, robotic or humanoid figure, perhaps with glowing eyes/limbs) stands centrally, subtly idling with micro-animations.
Menu Options (Pulsating Buttons/Nodes):
"START DEBUGGING" (main play option)
"LOAD PROGRAM" (load saved games)
"SETTINGS"
"LEADERBOARDS" (grayed out or "Coming Soon" if not implemented for challenge)
"EXIT"
Level Previews (When "START DEBUGGING" is selected):
A grid of stylized "program modules" (e.g., "Intro Module," "Loop Labyrinth," "Conditional Catastrophe").
Each module has a small thumbnail preview (abstract representations of the level's layout).
Locked levels are darker/have a lock icon.
Completed levels have a subtle "debugged" glow or a green checkmark.
Micro-Animation:
Player Idle: Subtle breathing, shifting weight, or flickering light on their body.
Menu Option Pulse: Each menu option subtly pulses or glows when highlighted/hovered over.
Connecting Lines: The lines connecting nodes in the background occasionally "light up" as if data is flowing through them.
Level Preview Hover: When hovering over a level, its thumbnail slightly expands and gets a brighter border.
Sound: Gentle electronic menu music. Distinct "select" and "hover" sounds.
User Interaction:
Navigation via arrow keys or mouse.
Enter/Space or mouse click to select.
Purpose: Provide access to game modes and settings. Visually represent progression through "programs" (levels).
Screen 4: Loading Screen (Pre-Level)
Visuals:
Background: Dark, with a central, evolving abstract data visualization.
Text: "LOADING PROGRAM: [Level Name]" in a clean, digital font.
Loading Bar/Indicator: A stylish, segmented loading bar or a circular progress indicator with flowing data particles.
Small Hints/Lore: Subtly cycling programming-related facts or lore about the "digital landscape" or "code corruption."
Micro-Animation:
Loading Bar Fill: Smooth, continuous fill with a subtle glow at the leading edge.
Data Visualization: The central visualization constantly changes, morphing and shifting as if processing data.
Hint Cycle: Hints fade in and out smoothly.
Sound: A low, rhythmic hum with intermittent bleeps and boops, building anticipation.
User Interaction: None, automatic transition.
Purpose: Mask loading times and build anticipation for the level.
Screen 5: Gameplay Screen (Core Loop)
Visuals:

Environment: 2D side-scrolling platformer. Levels are designed with a futuristic, abstract "code" aesthetic.
Platforms: Represented as lines of code, circuitry, or data blocks. Different colors for different "code types" (e.g., green for functions, blue for variables).
Background: Deep, layered parallax scrolling backgrounds with abstract circuit patterns, glowing data streams, and distant, non-intrusive representations of a corrupted network.
Hazards: "Bugs" (visualized as swirling red glitches, broken syntax symbols, or corrupted data clusters) that damage the player. "Inefficient code paths" could be visually represented by slow-moving, obstructive "data dust" or "redundant loops" that block progress.
Collectibles: "Data Bytes" (small, glowing blue bits of information) or "Syntax Fragments" (small, glowing green characters) that award points and contribute to level completion.
Player Character (Code Cleaner):
Idle: Subtle shifting, glowing elements.
Running: Smooth 2D sprite animation for legs/body movement.
Jumping: Arc animation.
Debugging/Interacting: Specific animations when performing "Q-Fixes."
HUD/UI:
Health Bar: Top-left, futuristic bar with glowing segments.
Q-Energy/Q-Ability Gauge: Top-right, charges as player collects "Data Bytes" or performs actions. This powers "Q-Fixes" and "Q-Optimizations."
Objective Tracker: Small icon/text in a corner (e.g., "Fix 3 Errors," "Optimize Pathway").
Current Code Snippet (Dynamic): A small, translucent overlay that displays the "buggy code" segment the player is currently interacting with or near.
Micro-Animation:
Player Movement: Smooth, fluid animations for walking, jumping, falling.
Enemy/Bug Animation: Jittering, glitching, or erratic movement for "bugs."
Data Bytes: Twinkling, rotating, or gently floating.
Q-Energy Charge: The gauge visibly fills with a glowing effect.
Code Snippet Interaction: When a player nears a buggy code segment, it subtly highlights, maybe with red lines/particles.
Explosion/Fix Effect: When a bug is fixed, a satisfying green burst of particles or a "clean code" visual effect.
Sound:
Background Music: Upbeat, electronic, driving soundtrack.
Player SFX: Footsteps (subtle clicks), jump sound (whoosh), landing sound (thump).
Bug SFX: Glitchy, buzzing, or distorted sounds.
Collectibles: Satisfying "ding" or "pop" when collected.
Q-Ability Activation: Distinct, powerful electronic "charge-up" and "release" sound effects.
Error Highlight: A subtle, digital "ping" when a bug is detected.
Code Fix: A rewarding "zap" or "clean" sound.
User Interaction (Key Mechanics):

Movement: Arrow keys/WASD for left/right, Up/Space for jump.
Q-Scan (Detect Bug): Player presses a designated key (e.g., 'Q').
Visual: A short-range, conical or circular scan emanates from the player. If a "bug" (corrupted code block or enemy) is within range, it gets a clear red highlight and a specific "error" icon appears above it.
Amazon Q Integration: This is where the player is "using" Amazon Q CLI to analyze the code. Conceptually, Q identifies the issue.
Q-Fix / Q-Refactor (Resolve Bug): After a "Q-Scan" identifies a bug, the player presses another key (e.g., 'E' or 'F').
Visual: The player character performs a short animation (e.g., extending an arm with a glow, or a rapid keyboard typing animation). A green "fix" or "optimization" effect envelops the bug. The bug disappears, or the corrupted code block transforms into clean, functional code.
Amazon Q Integration: This represents Amazon Q CLI providing the solution or refactoring suggestion. The visual effect makes it clear that Q is the source of the fix.
Cost: Uses "Q-Energy."
Puzzles:
Syntax Correction: Player encounters a broken bridge made of jumbled syntax. They must correctly order floating syntax fragments by touching them in sequence.
Loop Optimization: Player navigates a labyrinth where some paths are blocked by slow, "inefficient loops." Using Q-Refactor on a central "loop control" node clears the path.
Conditional Logic: Player needs to activate switches in a specific order based on visual cues (e.g., if X, then Y; else Z).
Resource Management: Limited Q-Energy encourages strategic use of Q-Fixes.
Purpose: The core gameplay loop of platforming, puzzle-solving, and utilizing AI-driven debugging abilities.

Screen 6: Level End / Debugged Screen
Visuals:
Background: The level's environment, but now completely "clean" and "optimized." All corrupted elements are gone, replaced by glowing, efficient code structures.
Central Element: The player character standing victorious.
Score/Stats Panel: A clean, digital panel pops up, displaying:
"PROGRAM DEBUGGED!" in large, satisfying text.
"Time Taken:"
"Bugs Fixed:"
"Q-Optimizations Used:"
"Data Bytes Collected:"
"Score:" (calculated based on efficiency, speed, etc.)
"New High Score!" indicator if applicable.
Buttons:
"NEXT PROGRAM"
"RETRY PROGRAM"
"MAIN MENU"
Micro-Animation:
Level Transformation: A subtle, pleasing visual transition where corrupted elements fade and clean ones glow into existence when the final objective is met.
Score Tally: Numbers rapidly count up to their final values.
Confetti/Sparkle: Small, digital "confetti" or green sparks erupt around the player/panel.
Sound: A triumphant, melodic completion sound. A satisfying "cash register" sound as score tallies.
User Interaction: Mouse clicks or keyboard navigation for buttons.
Purpose: Provide feedback on player performance and transition to the next level or menu.
Screen 7: Game Over / Program Crashed Screen
Visuals:
Background: Dark, chaotic, with rapidly flickering red and black "error" patterns. Visual noise and static.
Text: "PROGRAM CRASHED!" in a large, jarring, red, glitching font.
Player Character: The "Code Cleaner" sprite is broken, fragmented, or lying de-energized.
Stats (Optional): Similar to the end-of-level screen, but highlighting failures (e.g., "Bugs Missed," "Inefficiency").
Buttons:
"RETRY PROGRAM"
"MAIN MENU"
Micro-Animation:
Background Glitch: Constant, aggressive visual distortion and flickering.
Player Fragmentation: Player sprite visibly breaking apart.
Text Glitch: "PROGRAM CRASHED!" text constantly shifts and blurs.
Sound: A jarring, low-frequency hum with rapid, high-pitched error beeps and digital screams.
User Interaction: Mouse clicks or keyboard navigation for buttons.
Purpose: Indicate failure and offer options to restart or return to the menu.
Gen Z Appeal Summary:

Gamified Learning: Direct tie-in to programming concepts (debugging, optimization) in a fun, non-intimidating way.
Tech-Savvy Aesthetics: Modern, futuristic digital art style, appealing to those interested in tech and cyber culture.
Problem-Solving: Encourages critical thinking and logical deduction.
AI Integration: Showcases the practical application of AI (Amazon Q CLI) in a relatable context.
Satisfying Feedback: Clear visual and audio cues for success and failure, making progression feel rewarding.
This detailed breakdown provides a solid foundation for developing "CodeFlow: The Debugging Odyssey" in PyGame, incorporating all the requested elements.